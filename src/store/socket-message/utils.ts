import { ElementContent, Root, Element } from 'hast';
import rehypeParse from 'rehype-parse';
import rehypeStrigify from 'rehype-stringify';
import { Plugin, unified } from 'unified';
import { visit } from 'unist-util-visit';

const fixHtmlSourceUriPlugin: Plugin<[{ base: string }], Root, Root> =
  ({ base }) =>
  (tree) => {
    visit(
      tree,
      (node: any) =>
        ['img', 'video', 'audio', 'link', 'source'].includes(node.tagName),
      (node: any) => {
        const { src, href } = node.properties || {};
        if (src) {
          node.properties.src = new URL(src, base);
        }
        if (href) {
          node.properties.href = new URL(href, base);
        }
      },
    );
  };

export const getFixedPageMsg = async (htmlText: string, base: string) => {
  try {
    const processor = unified()
      .use(rehypeParse)
      .use(fixHtmlSourceUriPlugin, { base })
      .use(rehypeStrigify)
      .data('settings', { fragment: false });

    const file = await processor.process(htmlText);
    const html = file.toString();

    const tree = processor.parse(file).children as ElementContent[];
    console.log(tree);
    return {
      tree,
      html,
    };
  } catch (e) {
    console.error(e);
    return {
      tree: null,
      html: '',
    };
  }
};

interface WXDom {
  tag: string;
  attr: Record<string, any>;
  children?: WXDom[];
}

function transformDomProperties(props: Record<string, any>) {
  const res: Record<string, any> = {};
  Object.entries(props).forEach(([key, value]) => {
    if (typeof value === 'string') {
      res[key] = value;
    } else if (key === 'class' && value instanceof Array) {
      // class attribute could be a string or array of string
      res[key] = value.join(' ');
    } else if (typeof value === 'object') {
      if (value instanceof Array) {
        // in uniapp we found such case that the method binding is a deep array.
        res[key] = value.flat().join(',');
      }
    }
    // there could be other types of value, but we don't care about them at the moment.
    // like a function, or an object, usually for component props, which will be used in comp internally.
  });
  return res;
}

export const mpDomToElementTree = (
  wxDomList: WXDom[] = [],
): ElementContent[] => {
  const res: ElementContent[] = [];
  wxDomList.forEach((node) => {
    const tag = node.tag || '';
    if (tag === 'virtual') {
      // virtual is generated by if, for directive, should be ignored
      res.push(...mpDomToElementTree(node.children || []));
      return;
    }
    if (typeof node === 'string') {
      res.push({
        type: 'text',
        value: node,
      });
    }
    res.push({
      type: 'element',
      tagName: tag.startsWith('wx-') ? tag.substring(3) : tag, // remove wx- prefix
      properties: transformDomProperties(node.attr || {}),
      children: mpDomToElementTree(node.children),
    });
  });
  return res;
};
